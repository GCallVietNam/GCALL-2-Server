/*
This module consists of data manipulation in table Group
Group's fields:
- objectId:
	Unique ID of this record auto-generated by Parse
- hotline:
	Its hotline number
- groupId:
	Unique ID of this group, distinguished by its hotline and extension number
- name:
	Group name
- description:
	Description about this group
- subgroups:
	A string of its child extensions, delimitered by a comma
- pricing:
	Its pricing package
- registerAt:
	Time point of its package registration
- expireAt:
	Its package's expiry date time, equal to registerAt plus 30 days
- simultaneousSeconds:
	Number of seconds used for simultaneous calls
- lastCalculated:
	Time point at which simultaneousSeconds were last calculated
- topic:
	Its Amazon SNS topic, used for subscription and VoIP push
*/

'use strict';

const kaiseki=require('../config/parse-config');
const kai=require('../lib/kaiseki-promise')(kaiseki);
const Promise=require('bluebird');

const sns=require('../lib/aws-sns-promise');

const agentRepo=require('./agent');
const unsolvedRepo=require('./unsolved');

/*
Get one group in details by groupId, consisting of:
- objectId
- hotline
- name
- description
- type
- pricing

If its type is 'subgroup', it will also have:
- data:
	An array of its subgroups, each element contains:
	+ extension
	+ name
	+ description
	+ has: Whether this subgroup has any child subgroups or agents
	+ length: Number of this subgroup's child elements

If its type is 'agent', it will also have:
- topic:
	Its Amazon SNS topic, used for subscription and VoIP push
- data:
	An array of its agents, each element contains:
	+ fullname
	+ email
	+ phone
	+ accepted: Their working status in this group
*/

module.exports.getDetailedGroup=function(groupId){
	return new Promise((resolve,reject)=>{
		const params={
			where:{groupId:groupId}
		};
		kai.getObjectsAsync('Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject({type:'none',data:[],error:body.error});
				} else{
					if (body.results.length==0){
						reject({type:'none',data:[],error:'Group does not exist'});
					} else{
						const group=body.results[0];
						if (body.results[0].subgroups){
							const list=body.results[0].subgroups.split(',').map(
								(id)=>(groupId+'-'+id));
							const params={where:{groupId:{$in:list}}};
							kai.getObjectsAsync('Group',params).then(
								(result)=>{
									const body=JSON.parse(result.body);
									if (body.error){
										reject({type:'none',data:[],error:body.error});
									} else{
										var data=[];
										Promise.map(body.results,(group)=>{
											return new Promise(
												(res,rej)=>{
													const extension=group.groupId
														.substring(group.groupId.lastIndexOf('-')+1);
													var has='none';
													var length=0;
													if (group.subgroups){
														has='subgroup';
														length=group.subgroups.split(',').length;
														res({
															extension:extension,
															name:group.name,
															description:group.description,
															has:has,
															length:length
														});
													} else{
														const params={where:{groupId:group.groupId}};
														kai.getObjectsAsync('Agent_Group',params).then(
															(result)=>{
																const body=JSON.parse(result.body);
																if (body.error){
																	rej(body.error);
																} else{
																	if (body.results.length>0){
																		has='agent';
																		length=body.results.length;
																	}
																	res({
																		extension:extension,
																		name:group.name,
																		description:group.description,
																		has:has,
																		length:length
																	});
																}
															},
															(error)=>rej(error));
													}
												}).then(
													(result)=>data.push(result),
													(error)=>(error));
										}).then(
											(result)=>resolve({
												objectId:group.objectId,
												name:group.name,
												description:group.description,
												hotline:group.hotline,
												pricing:group.pricing,
												type:'subgroup',
												data:data,
												error:null
											}),
											(error)=>reject(error));
									}
								},
								(error)=>reject({type:'none',data:[],error:error}));
						} else{
							const params={where:{groupId:groupId}};
							kai.getObjectsAsync('Agent_Group',params).then(
								(result)=>{
									const body=JSON.parse(result.body);
									if (body.error){
										reject({
											objectId:null,
											hotline:null,
											type:'none',
											data:[],
											error:body.error
										});
									} else{
										if (body.results.length==0){
											resolve({
												objectId:group.objectId,
												name:group.name,
												description:group.description,
												hotline:group.hotline,
												pricing:group.pricing,
												type:'none',
												data:[],
												topic:group.topic,
												error:null
											});
										} else{
											resolve({
												objectId:group.objectId,
												name:group.name,
												description:group.description,
												hotline:group.hotline,
												pricing:group.pricing,
												type:'agent',
												data:body.results.map(
													(agent)=>({
														fullname:agent.fullname,
														email:agent.email,
														phone:agent.phone,
														accepted:agent.accepted
													})),
												topic:group.topic,
												error:null
											});
										}
									}
								},
								(error)=>reject({type:'none',data:[],error:error}));
						}
					}
				}
			},
			(error)=>reject({type:'none',data:[],error:error}));
	});
}

// Get a group by its groupId

module.exports.getGroupById=function(groupId){
	return new Promise((resolve,reject)=>{
		const params={where:{groupId:groupId}};
		kai.getObjectsAsync('Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results[0] || null);
				}
			},
			(error)=>reject(error));
	});
}

// Create a new group

module.exports.createGroup=function(data){
	return new Promise((resolve,reject)=>{
		kai.createObjectAsync('Group',data).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Update a group

module.exports.updateGroup=function(objectId,data){
	return new Promise((resolve,reject)=>{
		kai.updateObjectAsync('Group',objectId,data).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Delete a group

module.exports.deleteGroup=function(objectId){
	return new Promise((resolve,reject)=>{
		kai.deleteObjectAsync('Group',objectId).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Get agents in one group, sorting by their lastActive

module.exports.chooseAgents=function(groupId){
	return new Promise((resolve,reject)=>{
		this.getDetailedGroup(groupId).then(
			(result)=>{
				if (result.type=='agent'){
					const list=result.data.map((agent)=>(agent.email));
					const topic=result.topic;
					const params={
						where:{
							email:{$in:list},
							accepted:true,
							groupId:groupId
						},
						order:'lastActive'
					};
					kai.getObjectsAsync('Agent_Group',params).then(
						(result)=>{
							const agents=JSON.parse(result.body).results.map(
								(agent)=>({
									email:agent.email,
									phone:agent.phone,
									fullname:agent.fullname,
									subscriptions:agent.subscriptions,
									lastActive:agent.lastActive
								}));
							resolve({topic:topic,list:agents});
						},
						(error)=>reject(error));
				} else{
					reject('No agents in this group');
				}
			},
			(error)=>reject(error));
	});
}

// Verify if current user is this group's master or not

module.exports.authenticateMaster=function(groupId){
	return new Promise((resolve,reject)=>{
		kai.getCurrentUserAsync().then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					const hasGroups=body.hasGroups || [];
					const index=groupId.indexOf('-');
					const master=index>=0 ?
						groupId.substring(0,index) : groupId;
					if (hasGroups.indexOf(master)>=0){
						resolve(body);
					} else{
						reject('You do not own this group');
					}
				}
			},
			(error)=>reject(error));
	});
}

// Delete a group
// If this group has subgroups, delete all of them recursively
// If this group has agents, delete its topic and agents

module.exports.deleteWorkingGroup=function(groupId){
	return new Promise((resolve,reject)=>{
		this.getDetailedGroup(groupId).then(
			(result)=>{
				const group=result;
				if (group.type=='agent'){
					var promises=[];
					promises.push(agentRepo.getAgentsByGroup(groupId).then(
						(result)=>{
							Promise.map(result,(agent)=>
								agentRepo.deleteWorkingAgent(agent.email,groupId)
							).then(
								(result)=>{
									const params={TopicArn:group.topic};
									sns.deleteTopicAsync(params).then(
										(result)=>(result),
										(error)=>(error.message));
								},
								(error)=>(error));
						},
						(error)=>(error)));
					promises.push(unsolvedRepo.getUnsolvedByGroupId(groupId).then(
						(result)=>{
							Promise.map(result,(unsolved)=>
								unsolvedRepo.deleteUnsolved(unsolved.objectId)
							);
						},
						(error)=>(error)));
					Promise.all(promises).then(
						(result)=>this.deleteGroup(group.objectId).then(
							(result)=>resolve(result),
							(error)=>reject(error)),
						(error)=>reject(error));
				} else if (group.type=='subgroup'){
					Promise.map(group.data,(subgroup)=>
						this.deleteWorkingGroup(groupId+'-'+subgroup.extension)
					).then(
						(result)=>{
							this.deleteGroup(group.objectId).then(
								(result)=>resolve(result),
								(error)=>reject(error));
						},
						(error)=>reject(error));
				} else{
					this.deleteGroup(group.objectId).then(
						(result)=>resolve(result),
						(error)=>reject(error));
				}
			},
			(error)=>reject(error));
	});
}

// Remove an extension from a hotline after deleting respective subgroup

module.exports.removeExtension=function(groupId,extension){
	return new Promise((resolve,reject)=>{
		const params={
			where:{groupId:groupId}
		};
		kai.getObjectsAsync('Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					if (body.results.length==0){
						reject('Group does not exist');
					} else{
						const group=body.results[0];
						var subs=group.subgroups.split(',');
						const i=subs.indexOf(extension);
						if (i==-1){
							reject('This extension does not exist');
						} else{
							subs.splice(i,1);
							this.updateGroup(group.objectId,{subgroups:subs.join()}).then(
								(result)=>resolve(result),
								(error)=>reject(error));
						}
					}
				}
			},
			(error)=>reject(error));
	});
}

// Get all subgroups in a hotline

module.exports.getHotlineSubs=function(hotline){
	return new Promise((resolve,reject)=>{
		const params={
			where:{
				hotline:hotline,
				name:{$exists:true}
			}
		};
		kai.getObjectsAsync('Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}

// Check if current hotline package has enough authority to add more agent

module.exports.validateBeforeAddingAgent=function(hotline,limit){
	return new Promise((resolve,reject)=>{
		agentRepo.getAgentsByHotline(hotline).then(
			(result)=>{
				const count=result.length;
				if (count>=limit){
					reject('This hotline is only allowed to have '+limit+' agents at most');
				} else{
					resolve(true);
				}
			},
			(error)=>reject(error));
	});
}