/*
This module consists of data manipulation in table Agent_Group
Agent_Group's fields:
- objectId:
	Unique ID of this record auto-generated by Parse
- hotline:
	Hotline number of this group
- groupId:
	groupId of the group this agent is working for
- groupName:
	Name of the group this agent is working for
- email:
	Email of this agent
- fullname:
	Full name of this agent
- phone:
	Phone number of this agent
- accepted:
	Status of this agent, indicating they already accepted working invitation or not
- addedBy:
	Name of the group master who added this agent into this group
- lastActive:
	Last time point at which this agent received a call
- topic:
	The group's Amazon SNS topic, used for subscription and VoIP push
- subscriptions:
	List of their subscriptions to Amazon SNS topic, used for subscription and VoIP push
	Each contains:
	+ deviceType: Android or iOS device
	+ arn: Its ARN Endpoint on Amazon SNS Application
*/

'use strict';

const kaiseki=require('../config/parse-config');
const kai=require('../lib/kaiseki-promise')(kaiseki);
const Promise=require('bluebird');

const sns=require('../lib/aws-sns-promise');

// Create a new agent

module.exports.createAgent=function(data){
	return new Promise((resolve,reject)=>{
		kai.createObjectAsync('Agent_Group',data).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Get an agent by their email and groupId

module.exports.getAgent=function(data){
	return new Promise((resolve,reject)=>{
		const params={
			where:data
		};
		kai.getObjectsAsync('Agent_Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					if (body.results.length==0){
						reject('This agent is not in this group');
					} else{
						resolve(body.results[0]);
					}
				}
			},
			(error)=>reject(error));
	});
}

// Update an agent

module.exports.updateAgent=function(objectId,data){
	return new Promise((resolve,reject)=>{
		kai.updateObjectAsync('Agent_Group',objectId,data).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Delete an agent

module.exports.deleteAgent=function(objectId){
	return new Promise((resolve,reject)=>{
		kai.deleteObjectAsync('Agent_Group',objectId).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Get all groups an agent is working for by their email and status

module.exports.getGroupsByAgent=function(email,accepted){
	return new Promise((resolve,reject)=>{
		const params={
			where:{email:email,accepted:accepted}
		};
		kai.getObjectsAsync('Agent_Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}

// Get all agents in one group regardless of their status

module.exports.getAgentsByGroup=function(groupId){
	return new Promise((resolve,reject)=>{
		const params={
			where:{groupId:groupId}
		};
		kai.getObjectsAsync('Agent_Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}

// Delete a working agent in one group after unsubcribing

module.exports.deleteWorkingAgent=function(email,groupId){
	return new Promise((resolve,reject)=>{
		const data={email:email,groupId:groupId};
		this.getAgent(data).then(
			(result)=>{
				const agent=result;
				Promise.map(agent.subscriptions || [],(subscription)=>{
					const params={
						SubscriptionArn:subscription.arn
					};
					return sns.unsubscribeAsync(params).then(
						(result)=>(result),
						(error)=>(error.message));
				}).then(
					(result)=>{
						this.deleteAgent(agent.objectId).then(
							(result)=>resolve(result),
							(error)=>reject(error));
					},
					(error)=>reject(error[0]));
			},
			(error)=>reject(error));
	});
}

// Get all agents in one hotline regardless of their status

module.exports.getAgentsByHotline=function(hotline){
	return new Promise((resolve,reject)=>{
		const params={where:{hotline:hotline}};
		kai.getObjectsAsync('Agent_Group',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}