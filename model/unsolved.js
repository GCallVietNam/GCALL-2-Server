/*
This module consists of data manipulation in table Unsolved
Unsolved's fields:
- objectId:
	Unique ID of this record auto-generated by Parse
- hotline:
	Hotline number of the group receiving this unsolved call
- groupId:
	groupId of the group receiving this unsolved call
- groupName:
	Name of the group this agent is working for
- caller:
	Phone number of the caller who tried to call unsuccessfully
- master:
	Email of the group master
- solvedBy:
	Email of the agent who took over calling back
*/

'use strict';

const kaiseki=require('../config/parse-config');
const kai=require('../lib/kaiseki-promise')(kaiseki);
const Promise=require('bluebird');

// Create a new unsolved call

module.exports.createUnsolved=function(data){
	return new Promise((resolve,reject)=>{
		kai.createObjectAsync('Unsolved',data).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Get an unsolved call

module.exports.getUnsolved=function(id){
	return new Promise((resolve,reject)=>{
		kai.getObjectAsync('Unsolved',id).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body);
				}
			},
			(error)=>reject(error));
	});
}

// Delete an unsolved call

module.exports.deleteUnsolved=function(objectId){
	return new Promise((resolve,reject)=>{
		kai.deleteObjectAsync('Unsolved',objectId).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Get a list of unsolved calls by hotline's master

module.exports.getUnsolvedByMaster=function(email){
	return new Promise((resolve,reject)=>{
		const params={
			where:{master:email},
			order:'-createdAt'
		};
		kai.getObjectsAsync('Unsolved',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}

// Get a list of unsolved calls by groupId, sorting by time

module.exports.getUnsolvedByGroups=function(groups){
	return new Promise((resolve,reject)=>{
		const params={
			where:{
				groupId:{$in:groups},
				solvedBy:{$exists:false}
			},
			order:'-createdAt'
		};
		kai.getObjectsAsync('Unsolved',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}

// Solve an unsolved call

module.exports.solve=function(id,solvedBy){
	return new Promise((resolve,reject)=>{
		kai.updateObjectAsync('Unsolved',id,{solvedBy:solvedBy}).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Get a list of unsolved calls by hotline, sorting by time

module.exports.getUnsolvedByHotline=function(hotline){
	return new Promise((resolve,reject)=>{
		const params={
			where:{hotline:hotline},
			order:'-createdAt'
		};
		kai.getObjectsAsync('Unsolved',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}

// Get a list of unsolved calls by groupId

module.exports.getUnsolvedByGroupId=function(groupId){
	return new Promise((resolve,reject)=>{
		const params={
			where:{groupId:groupId}
		};
		kai.getObjectsAsync('Unsolved',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}