/*
This module consists of data manipulation in table Calllog
Calllog's fields:
- objectId:
	Unique ID of this record auto-generated by Parse
- accountSid:
	Hotline master's accountSid on Twilio
- authToken:
	Authority token of Twilio account / subaccount
- callSid:
	Unique callSid in Twilio
- groupId:
	groupId of the group receiving call
- hotline:
	Hotline that received call
- groupName:
	Name / Hotline of the group receiving call
- email:
	Email of the agent who received call
*/

'use strict';

const kaiseki=require('../config/parse-config');
const kai=require('../lib/kaiseki-promise')(kaiseki);
const Promise=require('bluebird');

// Store a calllog

module.exports.createCalllog=function(data){
	return new Promise((resolve,reject)=>{
		kai.createObjectAsync('Calllog',data).then(
			(result)=>{
				if (result.body.error){
					reject(result.body.error);
				} else{
					resolve(result.body);
				}
			},
			(error)=>reject(error));
	});
}

// Get a calllog by its callSid

module.exports.getCalllog=function(sid){
	return new Promise((resolve,reject)=>{
		const params={where:{callSid:sid}};
		kai.getObjectsAsync('Calllog',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results[0]);
				}
			})
	});
}

// Get a limited and paginated list of calllogs by an agent

module.exports.getCalllogsByEmail=function(email,limit,skip){
	return new Promise((resolve,reject)=>{
		const params={
			where:{
				email:email
			},
			limit:limit,
			skip:skip,
			order:'-createdAt'
		};
		kai.getObjectsAsync('Calllog',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}

// Get a list of calllogs in one hotline between two time points

module.exports.getCalllogsBetween=function(hotline,start,end){
	return new Promise((resolve,reject)=>{
		const params={
			where:{
				hotline:hotline,
				createdAt:{
					$gte:{
						__type:'Date',
						iso:start
					},
					$lte:{
						__type:'Date',
						iso:end
					},
				}
			},
			order:'createdAt'
		};
		kai.getObjectsAsync('Calllog',params).then(
			(result)=>{
				const body=JSON.parse(result.body);
				if (body.error){
					reject(body.error);
				} else{
					resolve(body.results);
				}
			},
			(error)=>reject(error));
	});
}